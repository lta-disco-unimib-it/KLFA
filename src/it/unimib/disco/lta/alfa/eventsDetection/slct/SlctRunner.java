package it.unimib.disco.lta.alfa.eventsDetection.slct;

import it.unimib.disco.lta.alfa.logging.Logger;
import it.unimib.disco.lta.alfa.utils.FileUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.LineNumberReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Formatter;
import java.util.List;
import java.util.regex.Pattern;





public class SlctRunner implements Slct {
	private String slctExecutablePath = null; //BY default use java slct //"slct";
	private String outliersFileName = "slctOutliers";
	
	private boolean intersectionEnabled = true;
	private double supportPercentage = 0.05;
	private double supportDecreaseFactor = 0.75;	//quantity for which the support percentage is multiplied when outliers remain the same
	private boolean iterateEnabled = true;
	private File workingDir = new File(".");
	private File outliersInputFile;
	

	public File getOutliersFile() {
		return outliersInputFile;
	}

	public SlctRunner(File workingDir){
		this.workingDir = workingDir;
		outliersInputFile = new File ( workingDir,  "outliersInputFile.txt" );
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		
		File filetoProcess = new File(args[args.length-1]);
		
		Slct r = new SlctRunner(new File("."));
		try {
			
			List<Pattern> slctrules = r.getRules(filetoProcess);
			
			
			System.out.println("Rules: ");
			for ( Pattern rule : slctrules ){
				System.out.println(rule.pattern());
			}
		} catch (SlctRunnerException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}

	/* (non-Javadoc)
	 * @see it.unimib.disco.lta.alfa.eventsDetection.slct.Slct#getRules(java.io.File)
	 */
	public List<Pattern> getRules(File fileToProcess) throws SlctRunnerException {


		List<Pattern> tmprules = process(fileToProcess);
		


		ArrayList<Pattern> rules = new ArrayList<Pattern>();

		for ( Pattern p : tmprules ){
			double words = p.pattern().split(" ").length;
			double parameters = p.pattern().split("\\(\\.\\*\\)").length;
			if ( words > 0.3 * parameters ){
				rules.add(p);
			}
		}
		return rules;




	}

	private List<Pattern> process(File fileToProcess) throws SlctRunnerException{
		
		File outliersFile = new File(workingDir,outliersFileName);
		
		File inputFile = fileToProcess;
		
		Logger.info("Processing the log file "+fileToProcess.getAbsolutePath());
		
		double currentSupport = supportPercentage;
		
		int outliersNumber;
		try {
			outliersNumber = FileUtils.getNumberOfLines(fileToProcess);
		} catch (IOException e1) {
			throw new SlctRunnerException(e1);
		}
		int support = (int) (currentSupport*outliersNumber);
		if ( support == 0 ){
			support = 2;
		}
		
		int oldOutliersNumber = outliersNumber;
		
		
		
		List<Pattern> rules = new ArrayList<Pattern>();
		
		do {
			
			
			

			try {
				
				SlctLauncher launcher;
				
				if ( slctExecutablePath != null ) {
					Logger.info("Using native slct");
					launcher = new SlctNativeLauncher(slctExecutablePath, intersectionEnabled);
				} else {
					Logger.info("Using JAVA slct");
					launcher = new SlctJavaLauncher();
				}
				
				Logger.info("Support: "+support+" Support percentage: "+currentSupport+" Input size: "+outliersNumber);
				List<Pattern> patternsDerived = launcher.run(support, inputFile, outliersFile);
				
				for ( Pattern p : patternsDerived){
					if ( ! p.pattern().equals("|") ){
						rules.add( p );
					}
				}
				
				
				StringBuffer sb = new StringBuffer();
				for ( Pattern p : rules ){
					sb.append(p.pattern()+FileUtils.lineSeparator);	
				}
				Logger.info("Rules derived :\n"+sb.toString());
				
				//In case no rules have been generated by slct the outliers file is not created
				if ( ! outliersFile.exists() ){
					outliersNumber = oldOutliersNumber;
					System.out.println("Not exists ");
				} else {
					outliersNumber = FileUtils.getNumberOfLines( outliersFile );
				}

				//if we have the same number of outliers as before reduce the support
				if ( oldOutliersNumber == outliersNumber ){
					currentSupport *= supportDecreaseFactor;
				}
				oldOutliersNumber = outliersNumber;
				
				support = (int) (currentSupport*outliersNumber);
				
				
				//The outliers are now the input
				if ( outliersFile.exists() ) {
					
					inputFile = outliersInputFile;
					
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					
					if ( ! outliersFile.renameTo(inputFile) ){
						
						FileUtils.copyFile(outliersFile, inputFile);
						
						//throw new SlctRunnerException("Unable to rename "+outliersFile.getAbsolutePath()+" to "+inputFile.getAbsolutePath());
					}
				}
			
			} catch (IOException e) {
				throw new SlctRunnerException(e);
			}
		} while ( iterateEnabled && support > 1);
		
		
		
		return rules;

	}



	public boolean isIntersectionEnabled() {
		return intersectionEnabled;
	}


	public void setIntersectionEnabled(boolean intersectionEnabled) {
		this.intersectionEnabled = intersectionEnabled;
	}

	public File getWorkingDir() {
		return workingDir;
	}

	public void setWorkingDir(File workingDir) {
		this.workingDir = workingDir;
	}

	public boolean isIterateEnabled() {
		return iterateEnabled;
	}

	public void setIterateEnabled(boolean iterateEnabled) {
		this.iterateEnabled = iterateEnabled;
	}

	/* (non-Javadoc)
	 * @see it.unimib.disco.lta.alfa.eventsDetection.slct.Slct#getSupportPercentage()
	 */
	public double getSupportPercentage() {
		return supportPercentage;
	}

	/* (non-Javadoc)
	 * @see it.unimib.disco.lta.alfa.eventsDetection.slct.Slct#setSupportPercentage(double)
	 */
	public void setSupportPercentage(double supportPercentage) {
		this.supportPercentage = supportPercentage;
	}

	/* (non-Javadoc)
	 * @see it.unimib.disco.lta.alfa.eventsDetection.slct.Slct#getSupportDecreaseFactor()
	 */
	public double getSupportDecreaseFactor() {
		return supportDecreaseFactor;
	}

	/* (non-Javadoc)
	 * @see it.unimib.disco.lta.alfa.eventsDetection.slct.Slct#setSupportDecreaseFactor(double)
	 */
	public void setSupportDecreaseFactor(double supportDecreaseFactor) {
		this.supportDecreaseFactor = supportDecreaseFactor;
	}

	public String getSlctExecutablePath() {
		return slctExecutablePath;
	}

	/**
	 * Set the complete path to the slct executable. E.g. /opt/slct/slct
	 * @param slctExecutablePath
	 */
	public void setSlctExecutablePath(String slctExecutablePath) {
		this.slctExecutablePath = slctExecutablePath;
	}

}
